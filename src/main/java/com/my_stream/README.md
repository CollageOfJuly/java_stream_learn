##Labmda表达式
java8的一种语法糖。函数式编程的重要体现，更关注的是对数据的处理。<br>
主要是对匿名内部类的省略，对于含单个方法的接口或抽象类，可通过Lambda表达式简化：
* 参数类型可以省略
* 方法体只有一句代码时，大括号、return以及代码的分号可以省略
* 方法只有一个参数时，小括号可以省略

匿名内部类格式，最终变成：(参数列表) -> {代码块}

##Stream流
> 常见操作
>> 创建流
> * 单列集合： `集合对象.stream()`
> * 数组：`Arrays.stream(数组) `或者使用`Stream.of(数组)`来创建
> * 双列集合：转换成单列集合后再创建。比如`map.entrySet().stream()`
>> 中间操作
> * filter：对流中的元素进行条件过滤，符合条件的留下
> * map：对流中的元素进行计算或转换
> * distinct：对流中的元素进行去重。要重写equals方法，最好也重写hashCode方法
> * sorted：对流中的元素进行排序。分为内部比较器(Comparable)和外部比较器(Comparator)
> * limit：对流中的元素进行限制
> * skip：对流中的元素进行跳过
> * flatMap：对流中每个元素进行拆分，组成一个新的流
>> 终结操作
> * forEach：对流中元素进行遍历操作
> * count：获取当前流中元素的个数
> * max&min：获取流中的最值
> * collect：把当前流转换成一个集合
> * 查询与匹配：
>   * anyMatch：可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。
>   * allMatch：可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。
>   * noneMatch：可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false
>   * findAny：获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。
>   * findFirst：获取流中的第一个元素。
> * reduce归并:对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）
>> 注意事项
> * 惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）
> * 流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）
> * 不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的。引用变量的修改会影响到原数据）

##Optional
一、创建对象  <br>
关键静态方法：ofNullable(xx)、of(xx)、empty()  <br>
二、获取值  <br>
关键非静态方法：get()、orElse(xx)、orElseGet(xx)、orElseThrow(xx)  <br>
三、消费值  <br>
关键非静态方法：ifPresent(xx)  <br>
四、过滤  <br>
关键非静态方法：filter(xx)  <br>
五、判断  <br>
关键非静态方法：isPresent()  <br>
六、数据转换  <br>
关键非静态方法：map(xx)  <br>

##函数式接口
只有一个抽象方法的接口，称之为函数式接口。 <br>
JDK提供了注解@FuntionalInterface进行标识。接口上加上此注解后，会严格要求接口有且只能存在一个抽象方法。
* 常用的默认方法：and、or、negate


##方法引用
我们在使用Lambda表达式时，如果匿名内部类中的方法体只有一个方法的调用（包括构造方法），则可以进一步简化代码
<br>
格式：`类名 :: 方法名`
<br>
分类：
* 引用类的静态方法
* 引用对象的实例方法
* 引用类的实例方法
* 构造器引用
##高级用法
* 基本数据类型优化
    * 创建的Stream流使用了泛型，所以参数和返回值都是引用数据类型。当对基本数据类型包装类进行计算时，拆装箱会比较消耗性能，所以Stream提供了很多针对基本数据类型优化的方法
    * 例如，mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble
* 并行流
    * 当Stream流中的元素非常多时，为了提高操作效率，可通过并行流将任务分配给多个线程去完成。
    * 可通过流对象的parallel()方法或创建流对象的parallelStream()获取
    * 另外：peek()方法可用来诊断流的操作过程